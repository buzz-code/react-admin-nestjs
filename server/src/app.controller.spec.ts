import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthService } from '@shared/auth/auth.service';
import { Response } from 'express';
import { UnauthorizedException } from '@nestjs/common';

describe('AppController', () => {
  let appController: AppController;
  let authService: AuthService;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [
        AppService,
        {
          provide: AuthService, useValue: {
            getCookieWithJwtToken: jest.fn(user => {
              if (user) return 'cookie';
              throw new UnauthorizedException();
            }),
            getCookieForImpersonate: jest.fn(user => {
              if (user) return 'cookie';
              throw new UnauthorizedException();
            }),
            getCookieForLogOut: jest.fn().mockResolvedValue('Authentication=; HttpOnly; Path=/; Max-Age=0; SameSite=true'),
            registerUser: jest.fn().mockRejectedValue(new UnauthorizedException()),
            getProfile: jest.fn().mockResolvedValue({}),
            updateSettings: jest.fn().mockResolvedValue({}),
          }
        },
      ],
    }).compile();

    appController = app.get<AppController>(AppController);
    authService = app.get<AuthService>(AuthService);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });

    // Generated by CodiumAI

    describe('AppController', () => {

      // The 'getHello' method returns 'Hello World!'
      it('should return "Hello World!" when calling getHello method', () => {
        expect(appController.getHello()).toBe('Hello World!');
      });

      // The 'login' method logs in a user and returns a success message
      it('should log in a user and return a success message when calling login method', async () => {
        const req = { user: { email: 'test@example.com' } };
        const res = { setHeader: jest.fn(), send: jest.fn() } as unknown as Response;

        await appController.login(req, res);

        expect(authService.getCookieWithJwtToken).toHaveBeenCalledWith(req.user);
        expect(res.setHeader).toHaveBeenCalledWith('Set-Cookie', 'cookie');
        expect(res.send).toHaveBeenCalledWith({ success: true });
      });

      // The 'register' method registers a user and returns a success message
      it('should register a user and return a success message when calling register method', async () => {
        const req = { user: { email: 'test@example.com' } };
        const res = { setHeader: jest.fn(), send: jest.fn() } as unknown as Response;

        await appController.register(req, res);

        expect(authService.getCookieWithJwtToken).toHaveBeenCalledWith(req.user);
        expect(res.setHeader).toHaveBeenCalledWith('Set-Cookie', 'cookie');
        expect(res.send).toHaveBeenCalledWith({ success: true });
      });

      // The 'login' method throws an UnauthorizedException if the user is not authenticated
      it('should throw an UnauthorizedException when calling login method with unauthenticated user', async () => {
        const req = { user: null };
        const res = { setHeader: jest.fn(), send: jest.fn() } as unknown as Response;

        await expect(appController.login(req, res)).rejects.toThrow(UnauthorizedException);
      });

      // The 'impersonate' method throws an UnauthorizedException if the user is not an admin
      it('should throw an UnauthorizedException when calling impersonate method with non-admin user', async () => {
        const req = { user: { permissions: {} }, body: { userId: 1 } };
        const res = { setHeader: jest.fn(), send: jest.fn() } as unknown as Response;

        await expect(appController.impersonate(req, res)).rejects.toThrow(UnauthorizedException);
      });

      // The 'logOut' method logs out a user and returns a success message
      it('should log out a user and return a success message', async () => {
        // Arrange
        const responseMock = {
          setHeader: jest.fn(),
          sendStatus: jest.fn(),
        } as unknown as Response;

        // Act
        await appController.logOut(responseMock);

        // Assert
        expect(responseMock.setHeader).toHaveBeenCalledWith(
          'Set-Cookie',
          expect.any(String)
        );
        expect(responseMock.sendStatus).toHaveBeenCalledWith(200);
      });

      // The 'getProfile' method returns the user's profile information
      it('should return the user\'s profile information when calling getProfile method', async () => {
        // Arrange
        const req = { user: { id: 1, email: 'test@example.com', name: 'Test User' } };
        const expectedProfile = { id: 1, email: 'test@example.com', name: 'Test User' };

        // Act
        const profile = await appController.getProfile(req);

        // Assert
        expect(profile).toEqual(expectedProfile);
      });

      // The 'impersonate' method impersonates a user and returns a success message
      it('should impersonate a user and return a success message', async () => {
        // Arrange
        const userId = 1;
        const responseMock = {
          setHeader: jest.fn(),
          send: jest.fn(),
        } as unknown as Response;
        const req = { body: { userId }, user: { permissions: { admin: true } } };

        // Act
        await appController.impersonate(req, responseMock);

        // Assert
        expect(authService.getCookieForImpersonate).toHaveBeenCalledWith(userId);
        expect(responseMock.setHeader).toHaveBeenCalledWith('Set-Cookie', 'cookie');
        expect(responseMock.send).toHaveBeenCalledWith({ success: true });
      });

      // The 'unimpersonate' method unimpersonates a user and returns a success message
      it('should unimpersonate a user and return a success message', async () => {
        // Arrange
        const responseMock = {
          setHeader: jest.fn(),
          sendStatus: jest.fn(),
          send: jest.fn(),
        } as unknown as Response;
        const getCookieForLogOutSpy = jest.spyOn(authService, 'getCookieForLogOut').mockResolvedValue('cookie');

        // Act
        await appController.unimpersonate({}, responseMock);

        // Assert
        expect(getCookieForLogOutSpy).toHaveBeenCalled();
        expect(responseMock.setHeader).toHaveBeenCalledWith('Set-Cookie', 'cookie');
        expect(responseMock.sendStatus).toHaveBeenCalledWith(200);
      });

      // The 'impersonate' method throws an UnauthorizedException if the user is not admin
      it('should throw UnauthorizedException when user is not admin', () => {
        // Arrange
        const responseMock = {
          setHeader: jest.fn(),
          sendStatus: jest.fn(),
        } as unknown as Response;
        const reqMock = {
          user: {
            permissions: {},
          },
        };

        // Act & Assert
        expect(() => appController.impersonate(reqMock, responseMock)).rejects.toThrow(UnauthorizedException);
      });

      // The 'getCookieForLogOut' method returns a cookie for logging out a user
      it('should return a cookie for logging out a user', async () => {
        // Arrange
        const responseMock = {
          setHeader: jest.fn(),
          sendStatus: jest.fn(),
        } as unknown as Response;

        // Act
        await appController.logOut(responseMock);

        // Assert
        expect(authService.getCookieForLogOut).toHaveBeenCalled();
        expect(responseMock.setHeader).toHaveBeenCalledWith('Set-Cookie', 'Authentication=; HttpOnly; Path=/; Max-Age=0; SameSite=true');
        expect(responseMock.sendStatus).toHaveBeenCalledWith(200);
      });

      it('should update user settings', async () => {
        // Arrange
        const req = { user: { id: 1 } };
        const data = { key: 'value' };

        // Act
        await appController.updateSettings(req, data);

        // Assert
        expect(authService.updateSettings).toHaveBeenCalledWith(1, data);
      });
    });

  });
});
